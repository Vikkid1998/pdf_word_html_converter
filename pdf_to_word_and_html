#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Simplified version:
- You only give --input (folder containing PDFs and/or DOCXs).
- Script creates "docx_out" and "html_out" inside that folder automatically.
- PDF → DOCX → HTML pipeline with bold + page break preservation.
"""

import os
import sys
import argparse
import shutil
import html
from pathlib import Path

from tqdm import tqdm
from pdf2docx import Converter
from docx import Document
from docx.oxml.ns import qn
from lxml import etree


def safe_mkdir(p: Path):
    p.mkdir(parents=True, exist_ok=True)


def pdf_to_docx(pdf_path: Path, out_dir: Path) -> Path:
    """Convert a single PDF to DOCX."""
    out_docx = out_dir / (pdf_path.stem + ".docx")
    if out_docx.exists() and out_docx.stat().st_size > 1024:
        return out_docx
    cv = Converter(str(pdf_path))
    cv.convert(str(out_docx))
    cv.close()
    return out_docx


def iter_block_items(doc):
    body = doc.element.body
    for child in body.iterchildren():
        if child.tag == qn("w:p"):
            yield ("p", child)
        elif child.tag == qn("w:tbl"):
            yield ("tbl", child)


def paragraph_runs_to_html(p_element):
    ns = {"w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main"}
    runs_html = []
    for r in p_element.xpath(".//w:r", namespaces=ns):
        # handle breaks
        brs = r.xpath(".//w:br", namespaces=ns)
        for br in brs:
            br_type = br.get(qn("w:type"))
            if br_type == "page":
                runs_html.append('<hr class="page-break" />')
            else:
                runs_html.append("<br>")
        # text
        texts = r.xpath(".//w:t", namespaces=ns)
        text_content = "".join(t.text or "" for t in texts)
        if not text_content and not brs:
            continue
        text_escaped = html.escape(text_content)
        # bold detection
        is_bold = False
        rpr = r.find("w:rPr", ns)
        if rpr is not None:
            b = rpr.find("w:b", ns)
            bcs = rpr.find("w:bCs", ns)
            is_bold = (b is not None and b.get(qn("w:val"), "true") != "false") or (bcs is not None)
        if is_bold and text_escaped:
            runs_html.append(f"<strong>{text_escaped}</strong>")
        else:
            runs_html.append(text_escaped)
    joined = "".join(runs_html).strip()
    return f"<p>{joined}</p>"


def table_to_html(tbl_element):
    ns = {"w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main"}
    html_rows = []
    for tr in tbl_element.xpath("./w:tr", namespaces=ns):
        cells_html = []
        for tc in tr.xpath("./w:tc", namespaces=ns):
            parts = []
            for child in tc.iterchildren():
                if child.tag == qn("w:p"):
                    parts.append(paragraph_runs_to_html(child))
                elif child.tag == qn("w:tbl"):
                    parts.append(table_to_html(child))
            cells_html.append(f"<td>{''.join(parts)}</td>")
        html_rows.append(f"<tr>{''.join(cells_html)}</tr>")
    return f"<table>{''.join(html_rows)}</table>"


def docx_to_html(docx_path: Path, html_out_dir: Path) -> Path:
    doc = Document(str(docx_path))
    out_html = html_out_dir / f"{docx_path.stem}.html"
    head = (
        "<!DOCTYPE html><html lang='en'><head><meta charset='utf-8'>"
        f"<title>{html.escape(docx_path.stem)}</title>"
        "<style>body{font-family:Arial,Helvetica,sans-serif;line-height:1.5;margin:16px;}"
        "p{margin:0 0 8px 0;white-space:pre-wrap;}"
        "table{border-collapse:collapse;margin:8px 0;width:100%;}"
        "td,th{border:1px solid #ddd;padding:6px;vertical-align:top;}"
        ".page-break{border:0;border-top:1px dashed #999;margin:12px 0;height:0;}"
        "</style></head><body>"
    )
    body_parts = []
    for kind, element in iter_block_items(doc):
        if kind == "p":
            body_parts.append(paragraph_runs_to_html(element))
        elif kind == "tbl":
            body_parts.append(table_to_html(element))
    html_text = head + "".join(body_parts) + "</body></html>"
    out_html.write_text(html_text, encoding="utf-8")
    return out_html


def main():
    ap = argparse.ArgumentParser(description="Convert PDFs in a folder to DOCX and HTML")
    ap.add_argument("--input", required=True, help="Input folder containing PDFs and/or DOCXs")
    args = ap.parse_args()

    input_dir = Path(args.input).resolve()
    if not input_dir.exists() or not input_dir.is_dir():
        print(f"ERROR: Input folder does not exist: {input_dir}", file=sys.stderr)
        sys.exit(1)

    # auto-create subfolders
    docx_out = input_dir / "docx_out"
    html_out = input_dir / "html_out"
    safe_mkdir(docx_out)
    safe_mkdir(html_out)

    # collect files
    pdfs = sorted([f for f in input_dir.iterdir() if f.suffix.lower() == ".pdf"])
    docxs = sorted([f for f in input_dir.iterdir() if f.suffix.lower() == ".docx"])

    # step 1: PDFs -> DOCX
    for pdf in tqdm(pdfs, desc="PDF -> DOCX", unit="file"):
        try:
            pdf_to_docx(pdf, docx_out)
        except Exception as e:
            print(f"[WARN] Failed PDF->DOCX {pdf}: {e}", file=sys.stderr)

    # step 2: also copy existing DOCX
    for docx in docxs:
        target = docx_out / docx.name
        if not target.exists():
            shutil.copy2(docx, target)

    # step 3: DOCX -> HTML
    docx_list = sorted([f for f in docx_out.iterdir() if f.suffix.lower() == ".docx"])
    for docx in tqdm(docx_list, desc="DOCX -> HTML", unit="file"):
        try:
            docx_to_html(docx, html_out)
        except Exception as e:
            print(f"[WARN] Failed DOCX->HTML {docx}: {e}", file=sys.stderr)

    print("Done. DOCX in:", docx_out, " | HTML in:", html_out)


if __name__ == "__main__":
    main()
